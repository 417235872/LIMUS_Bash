# 笔记

# Alpha0.1构架思路

最初版的DAQ软件构架思路

当前版本的软件又两大模块组成，提供了基本的功能，尝试搭建基本的软件框架。

## 1.设备通讯模块

设备通讯模块通过Python调用C#DLL库，开启通讯进程。目前支持功能：搜索USB设备、配置SlowControl，配置Probe，开关/调节高压，接收数据(以二进制保存到文件中)，自动配置(搜寻USB设备>>配置SlowControl>>配置Probe>>调节高压>>开启接收数据线程)。

## 2.terminal模块

通过Python构建的一个在命令行接收操作指令的进程，

开启时会

通过input进行接收命令，内部通过处理字符串信息来向设备通讯模块发送操作流。

## 3.进程间通讯

进程间通讯目前采用Queue队列进行通讯，

进程间发送字典格式的对象进行操作指令和操作反馈



## python调用C#动态库

### 导入动态库

```python
import sys
import clr
sys.path.append(r'A:\工作\实验室\LUMIS\DAQ_IO\DAQ_IO\bin\Debug')#添加存放dll的文件夹到系统路径中
clr.AddReference('DAQ_IO')#添加dll库
from DAQ_IO_DLL import function_test#DAQ_IO_DLL是命名空间
```

变量对应

| Python         | C#      |
| -------------- | ------- |
| int            | int     |
| str            | string  |
| bool           | bool    |
| System.Decimal | decimal |
| bytes<----     | byte[]  |



# python多进程

### 简单示例

```python
from multiprocessing import Process
import os

def info(title):
    print(title)
    print('module name:', __name__)
    print('parent process:', os.getppid())
    print('process id:', os.getpid())

def f(name):
    info('function f')
    print('hello', name)

if __name__ == '__main__':
    info('main line')
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()
```

 输出

```
main line
module name: __main__
parent process: 13856
process id: 18048
function f
module name: __mp_main__
parent process: 18048
process id: 18248
hello bob
```



### 启动方法

> ##### *spawn*
>
> 父进程启动一个新的Python解释器进程。子进程只会继承那些运行进程对象的 [`run()`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Process.run) 方法所需的资源。特别是父进程中非必须的文件描述符和句柄不会被继承。相对于使用 *fork* 或者 *forkserver*，使用这个方法启动进程相当慢。
>
> 可在Unix和Windows上使用。 Windows上的默认设置。
>
> ##### *fork*
>
> 父进程使用 [`os.fork()`](https://docs.python.org/zh-cn/3.7/library/os.html#os.fork) 来产生 Python 解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。
>
> 只存在于Unix。Unix中的默认值。
>
> ##### *forkserver*
>
> 程序启动并选择* forkserver * 启动方法时，将启动服务器进程。从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。分叉服务器进程是单线程的，因此使用 [`os.fork()`](https://docs.python.org/zh-cn/3.7/library/os.html#os.fork) 是安全的。没有不必要的资源被继承。

 **要选择一个启动方法，你应该在主模块的 `if __name__ == '__main__'` 子句中调用 [`set_start_method()`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.set_start_method)** 。

```python
import multiprocessing as mp

def foo(q):
    q.put('hello')

if __name__ == '__main__':
    mp.set_start_method('spawn')
    q = mp.Queue()
    p = mp.Process(target=foo, args=(q,))
    p.start()
    print(q.get())
    p.join()
```

**警告**

**`'spawn'` 和 `'forkserver'` 启动方法当前不能在Unix上和“冻结的”可执行内容一同使用（例如，有类似 PyInstaller 和 cx_Freeze 的包产生的二进制文件）。 `'fork'` 启动方法可以使用。**



### 在进程之间交换对象[¶](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#exchanging-objects-between-processes)

[`multiprocessing`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing) 支持进程之间的两种通信通道：

**队列**

> [`Queue`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Queue) 类是一个近似 [`queue.Queue`](https://docs.python.org/zh-cn/3.7/library/queue.html#queue.Queue) 的克隆。 例如:
>
> ```python
> def f(q):
>  q.put([42, None, 'hello'])
> 
>    if __name__ == '__main__':
>  q = Queue()
>  p = Process(target=f, args=(q,))
>     p.start()
>     print(q.get())    # prints "[42, None, 'hello']"
>     p.join()
>    ```
>    
> 队列是线程和进程安全的。

**管道**

> [`Pipe()`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Pipe) 函数返回一个由管道连接的连接对象，默认情况下是双工（双向）。例如:
>
> ```python
> from multiprocessing import Process, Pipe
> 
> def f(conn):
>     conn.send([42, None, 'hello'])
>     conn.close()
> 
> if __name__ == '__main__':
>     parent_conn, child_conn = Pipe()
>     p = Process(target=f, args=(child_conn,))
>     p.start()
>     print(parent_conn.recv())   # prints "[42, None, 'hello']"
>     p.join()
> ```



### 进程之间的同步

[`multiprocessing`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing) 包含来自 [`threading`](https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading) 的所有同步原语的等价物。例如，可以使用锁来确保一次只有一个进程打印到标准输出:

```
from multiprocessing import Process, Lock

def f(l, i):
    l.acquire()
    try:
        print('hello world', i)
    finally:
        l.release()

if __name__ == '__main__':
    lock = Lock()

    for num in range(10):
        Process(target=f, args=(lock, num)).start()
```

不使用来自不同进程的锁输出容易产生混淆。

# python小问题

#### 1.windows上Python子进程不能访问控制台，所以input只能在主进程进行。

#### 2.python：动态打印

```python
 import time 
 for i in range(11):
    time.sleep(0.5)
    print('\r当前进度：{0}{1}%'.format('▉'*i,(i*10)), end='')
    print('加载完成！') 
```

 \r是将光标移到一行的开始，所以\r之后的内容会覆盖掉上次打印的内容，形成动态打印。
效果图： 

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613195922173.gif)





# Alpha0.2构架思路

版本Alpha0.1具有许多的缺陷：

1. 当terminal进程崩溃之后，虽然设备通讯进程不会受影响，但是重启terminal进程不能重新与设备通讯进程建立连接
2. 由于从Python调用C#DLL库，许多在C#中的状态参数和反馈在Python中接收和处理不便，不能很好的进行控制。
3. 设备通讯进程和terminal进程构架的扩展性太差

Alpha0.2采用网络编程的思路，将与设备操作的进程模块构架成一个本地服务，通过socket套接字进行操作流的通讯，套接字发送XML格式的数据，同时通过XML文件进行配置信息的存储和交互。

## server构架

sever主要在C#下构架，Python只做开启C#进程的作用。

1. 对于Alpha0.1的C#库函数大体不变，但是要对于部分函数进行修改，添加部分功能，重新实现部分功能：

   | 类          | 函数                                            | 修改情况                                                     | 备注     |
   | ----------- | ----------------------------------------------- | ------------------------------------------------------------ | -------- |
   | DAQ_IO_DLL  | check_USB(bool link=True)                       | 添加了参数，当link为False时，可以只查找USB设备而不重新连接USB设备 | 重构功能 |
   | SC_model_2E | saveAsXML(string path = "./myConfigurtion.xml") | 将SlowControl的配置情况按照XML格式存储起来                   | 添加功能 |
   | SC_model_2E | load_XML(string path = “./myConfigurtion.xml”)  | 载入XML，按照XML内的参数对配置进行修改配置                   | 添加功能 |

   

2.  C#内添加socket通讯模块，包括socket服务器端、解析客户端请求。

3. server进程直接由C#开启，所以需要C#内部开启服务进程

## client构架

Alpha0.2中简单构架命令行中的client，实际可构架client如下：

1. 仿照Alpha0.1在Python界面进行构架terminal进程，通过socket连接server进程，解析处理输入字符串命令，向server发送命令流
2. 编写多个类脚本式命令，直接在命令行中运行命令，每个命令通过socket与server进行一次连接，传输相应命令流。
3. 在Python交互式界面、jupyte界面直接操作client类进行命令流通讯
4. 基于client类建立GUI交互式界面

### 构架思路

client分为三部分

第一部分是socket连接通讯模块

第二部分是解析命令流模块

第三部分是人机交互模块

对于数据分析功能另行编写

## socket套接字

####  服务器端：

  01，申请一个socket

  02，绑定到一个IP地址和一个端口上

  03，开启侦听，等待接收连接

####  客户端：

  01，申请一个socket

  02，连接服务器(指明IP地址和端口号)

  服务器端接收到连接请求后，产生一个新的socket(端口大于1024)与客户端建立连接并进行通信，原监听socket继续监听。

 注意：负责通信的Socket不能无限创建，创建的数量和操作系统有关。

### C#代码实现：示例(服务端)

```C#
using System.Net.Sockets;
using System.Threading;
namespace test_socket
{
	//创建套接字  
    static Socket socket = new Socket(AddressFamily.InterNetwork, 		SocketType.Stream, ProtocolType.Tcp);
    //接收数据的缓冲区
    private static byte[] result = new byte[1024];
    //主函数
    static void Main(string[] args)
    {
        SocketServie();
    }
    //创建socket服务端进程
    public static void SocketServie()
    {
        Console.WriteLine("服务端已启动");
        string host = "127.0.0.1";//IP地址
        int port = 2000;//端口
        socket.Bind(new IPEndPoint(IPAddress.Parse(host), port));
        socket.Listen(5);//设定最多5个排队连接请求   
        Thread myThread = new Thread(ListenClientConnect);//通过多线程监听客户端连接  
        myThread.Start();
        Console.ReadLine();
    }

    /// <summary>  
    /// 监听客户端连接  
    /// </summary>  
    private static void ListenClientConnect()
    {
        while (true)
        {
            Socket clientSocket = socket.Accept();//Accept 从侦听套接字的连接请求队列中同步提取第一个挂起的连接请求，然后创建并返回新的 Socket。未获取时会阻塞
            clientSocket.Send(Encoding.UTF8.GetBytes("服务器连接成功"));//向socket客户端发送数据
            Thread receiveThread = new Thread(ReceiveMessage);//建立获取socket数据线程
            receiveThread.Start(clientSocket);//开启线程
        }
    }

    /// <summary>  
    /// 接收消息  
    /// </summary>  
    /// <param name="clientSocket"></param>  
    private static void ReceiveMessage(object clientSocket)
    {
        Socket myClientSocket = (Socket)clientSocket;
        while (true)
        {
            try
            {
                //通过clientSocket接收数据  
                int receiveNumber = myClientSocket.Receive(result);
                if (receiveNumber == 0)
                    return;
                Console.WriteLine("接收客户端{0} 的消息：{1}", myClientSocket.RemoteEndPoint.ToString(), Encoding.UTF8.GetString(result, 0, receiveNumber));
                //给Client端返回信息
                string sendStr = "已成功接到您发送的消息";
                byte[] bs = Encoding.UTF8.GetBytes(sendStr);//Encoding.UTF8.GetBytes()不然中文会乱码
                myClientSocket.Send(bs, bs.Length, 0);  //返回信息给客户端
                myClientSocket.Close(); //发送完数据关闭Socket并释放资源
                Console.ReadLine(); 
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                myClientSocket.Shutdown(SocketShutdown.Both);//禁止发送和上传
                myClientSocket.Close();//关闭Socket并释放资源
                break;
            }
        }
    }
}
```

### Python代码：示例(客户端)

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名：client.py
 
import socket               # 导入 socket 模块
 
s = socket.socket()         # 创建 socket 对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口号
 
s.connect((host, port))		# 连接socket服务端
print(s.recv(1024))			# 打印接收数据
s.close()					# 关闭socket连接
```

#### Python中的socket内建方法说明：

| 函数                                                         | 参数说明                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 初始化创建套接字                                             |                                                              |                                                              |
| `socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)` | **family:** 套接字家族可以使`AF_UNIX`或者`AF_INET`。**type:** 套接字类型可以根据是面向连接的还是非连接分为`SOCK_STREAM`或`SOCK_DGRAM`。**protocol:** 一般不填默认为0. | socket（）函数来创建套接字。                                 |
| 客户端套接字                                                 |                                                              |                                                              |
| `socket.create_connection(address[, timeout[, source_address]])` | **address:**一般address的格式为元组（hostname,port）。       | `连接到一个 TCP 服务，该服务正在侦听 Internet *address* （用二元组 (host, port) 表示）连接后返回套接字对象。` |
| `socket.connect_ex(address)`                                 | **address:**一般address的格式为元组（hostname,port）。       | connect()函数的扩展版本,出错时返回出错码,而不是抛出异常      |
| 公共用途的套接字函数                                         |                                                              |                                                              |
| `socket.recv(bufsize[,flag])`                                | **bufsize:**指定要接收的最大数据量。**flag:**提供有关消息的其他信息，通常可以忽略。 | 接收TCP数据，数据以字符串形式返回。                          |
| `socket.send(string)`                                        | 将**string**中的数据发送到连接的套接字。                     | 发送TCP数据，返回值是要发送的字节数量，该数量可能小于string的字节大小。 |
| `socket.close()`                                             |                                                              | 关闭套接字                                                   |

### TCP协议和UDP协议

在之前的示例中使用的都是TCP协议进行通讯，但是TCP协议并不适合本项目：

TCP协议主要是面向字节流的传输连接，为了节省网络带宽，windows对传输进行了优化，建立了输入和输出缓冲区，大小为8KB，只有等到缓冲区被填满时才flush一次数据。对于小数据的传输会有巨大的延迟等待，常常发送指令后很长一段时间内无法从缓冲区flush。

UDP协议主要是面向数据报，采用UDP协议可以有效解决数据长时间滞留在缓冲区的问题。

#### TCP协议与UDP协议的区别

- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证

##### UDP特点

- 沟通简单，不需要大量的数据结构，处理逻辑和包头字段
- 轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。
- 愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发

##### 应用场景

- 需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。
- 不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候
- 需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候

##### UDP代码实现区别

客户端:

- 由于是面向无连接的协议，所以不用对连接请求进行监听，只需要监听对应端口的数据即可。

##### C#代码实现

```C#
        public static void SocketServer_UDP()
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            string host = "127.0.0.1";
            int port = 2000;
            socket.Bind(new IPEndPoint(IPAddress.Parse(host), port));
            Console.WriteLine("server is already.");
            Thread recvUDP = new Thread(ReceiveMessage_UDP);
            recvUDP.Start();

        }
        private static void ReceiveMessage_UDP()
        {
            int recvNum;
            StringBuilder recvXML = new StringBuilder();
            EndPoint EP = new IPEndPoint(IPAddress.Any, 0);
            EndPoint clientEP = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 2001);
            while (true)
            {
                Console.WriteLine("still alive.");
                try
                {
                    recvNum = socket.ReceiveFrom(result,ref EP);//这是一个阻塞项
                    if (recvNum < 1024)
                    {
                        Console.WriteLine(Encoding.UTF8.GetString(result, 0, recvNum));
                        socket.SendTo(Encoding.UTF8.GetBytes("get it!"), clientEP);
                    }
                    else if (recvXML.Length == 0)
                    {
                        recvXML.Append(Encoding.UTF8.GetString(result, 0, recvNum));
                        Console.WriteLine(recvNum.ToString());
                        Console.WriteLine(recvXML);
                        socket.Send(Encoding.UTF8.GetBytes("get it!"));
                        recvXML.Clear();
                    }
                    else
                    {
                        
                        Thread.Sleep(1000);
                    }
                }
                catch (SocketException se)
                {
                    socket.Close();
                    break;
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    socket.Send(Encoding.UTF8.GetBytes("0"));
                    socket.Close();
                    break;
                }
            }
        }
```

##### python代码实现

```python
import  socket,time
s = socket.socket(type=socket.SOCK_DGRAM)
host = '127.0.0.1'
port = 2000
address = (host,port)
s.bind((host,port+1))
for i in range(10):
    s.sendto('Good luck!'.encode("utf-8"),address)
    time.sleep(1)
    print(s.recvfrom(1024))
s.close()
```



## XML解析和创建

client将生成对应的格式XML文件，由此指定的配置参数值，server服务端的配置参数将读取XML文件，对默认的configure参数进行修改。

client与server的通讯结构也拟以XML格式进行传输，方便对数据内容进行解析和扩展。

### C#解析和创建XML

C#中对XML的操作可以分为两类：

第一类是对XML文档的解析和创建。

C#通过内建模块[XmlDocument](https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmldocument?view=netcore-3.1#Find)对XML文档进行操作， 可使用此类在文档中加载、验证、编辑、添加和放置 XML。 

第二类是将已有的对象序列化为XML文件或将XML文件反序列化为C#对象。

C#通过内建模块`XmlSerializer`将对象序列化到 XML 文档中和从 XML 文档中反序列化对象。 `XmlSerializer`使您得以控制如何将对象编码到 XML 中。 

#### 用途

1. 对于server与client之间的通讯是以XML的格式进行通讯，C#内对client中传入的字节流先转化成string对象，然后使用将调用`XmlDocument`模块对具有Xml格式的string进行解析，得到指令内容。
2. C#中拟将`SC_Model_2E`和`probe_Model`的参数，通过`XmlSerializer`序列化为xml格式的数据，client通过读取xml文件来获取当前配置情况，同时通过修改xml文件，server中反序列化xml文件成`SC_Model_2E`和`probe_Model`对象来修改配置情况。

#### 简略教程

##### 1.加载XML

```C#
XmlDocument doc = new XmlDocument();
doc.PreserveWhitespace = true;//保留空白字符
try 
{
    doc.Load("booksData.xml");//从文件中加载xml
}
catch (System.IO.FileNotFoundException)
{
    doc.LoadXml("<?xml version=\"1.0\"?> \n" +
    "<books xmlns=\"http://www.contoso.com/books\"> \n" +
    "  <book genre=\"novel\" ISBN=\"1-861001-57-8\" publicationdate=\"1823-01-28\"> \n" +
    "    <title>Pride And Prejudice</title> \n" +
    "    <price>24.95</price> \n" +
    "  </book> \n" +
    "  <book genre=\"novel\" ISBN=\"1-861002-30-1\" publicationdate=\"1985-01-01\"> \n" +
    "    <title>The Handmaid's Tale</title> \n" +
    "    <price>29.95</price> \n" +
    "  </book> \n" +
    "</books>");//从字符串中加载xml
}
```

##### 2.在文件树中导航

​	XML文档由节点组成。 每个节点在其上都有一个直接的*父*节点。 唯一没有父节点的节点是文档根，因为它是顶级节点。 大多数节点可以有*子*节点，子节点直接位于其下。 处于相同级别的节点是*同级*节点。 

1. 获取根节点

   ```c#
   using System;
   using System.IO;
   using System.Xml;
   
   public class Sample
   {
     public static void Main()
     {
       //Create the XmlDocument.
       XmlDocument doc = new XmlDocument();
       doc.LoadXml("<?xml version='1.0' ?>" +
                   "<book genre='novel' ISBN='1-861001-57-5'>" +
                   "<title>Pride And Prejudice</title>" +
                   "</book>");
   
       //Display the document element.
       Console.WriteLine(doc.DocumentElement.OuterXml);
    }
   }
   ```

   `doc.DocumentElement`获取根节点对象，通过`.OuterXml`来将其输出为string。

2. 获取子节点

    此示例跳转到根节点的第一个子节点，然后循环访问该节点的子节点（如果存在）。

   ```c#
   using System;
   using System.IO;
   using System.Xml;
   
   public class Sample {
   
     public static void Main() {
   
       XmlDocument doc = new XmlDocument();
       doc.LoadXml("<book ISBN='1-861001-57-5'>" +
                   "<title>Pride And Prejudice</title>" +
                   "<price>19.95</price>" +
                   "</book>");
   
       XmlNode root = doc.FirstChild;//get the first child element for root element.But you'll usually get the element that represents version information.
   
       //Display the contents of the child nodes.
       if (root.HasChildNodes)
       {
         for (int i=0; i<root.ChildNodes.Count; i++)
         {
           Console.WriteLine(root.ChildNodes[i].InnerText);
         }
       }
     }
   }
   ```

    

3. 返回父节点

4. 获取最后一个子节点

   ```C#
   using System;
   using System.IO;
   using System.Xml;
   
   public class Sample {
   
     public static void Main() {
   
       XmlDocument doc = new XmlDocument();
       doc.LoadXml("<book ISBN='1-861001-57-5'>" +
                   "<title>Pride And Prejudice</title>" +
                   "<price>19.95</price>" +
                   "</book>");
   
       XmlNode root = doc.FirstChild;
   
       Console.WriteLine("Display the price element...");
       Console.WriteLine(root.LastChild.OuterXml);
     }
   }
   ```

5. 同级节点之间向前导航

   ```C#
   using System;
   using System.Xml;
   
   public class Sample {
   
     public static void Main() {
   
         XmlDocument doc = new XmlDocument();
         doc.Load("books.xml");
   
         XmlNode currNode = doc.DocumentElement.FirstChild;
         Console.WriteLine("First book...");
         Console.WriteLine(currNode.OuterXml);
   
         XmlNode nextNode = currNode.NextSibling;
         Console.WriteLine("\r\nSecond book...");
         Console.WriteLine(nextNode.OuterXml);
     }
   }
   ```

   

6. 同级节点之间向后导航

   ```C#
   using System;
   using System.Xml;
   
   public class Sample {
   
     public static void Main() {
   
         XmlDocument doc = new XmlDocument();
         doc.Load("books.xml");
   
         XmlNode lastNode = doc.DocumentElement.LastChild;
         Console.WriteLine("Last book...");
         Console.WriteLine(lastNode.OuterXml);
   
         XmlNode prevNode = lastNode.PreviousSibling;
         Console.WriteLine("\r\nPrevious book...");
         Console.WriteLine(prevNode.OuterXml);
     }
   }
   ```

3.查找节点

4.编辑节点



```C#
public void editBook(string title, string ISBN, string publicationDate,
    string genre, string price, XmlNode book, bool validateNode, bool generateSchema)
{

    XmlElement bookElement = (XmlElement)book;

    // Get the attributes of a book.
    bookElement.SetAttribute("ISBN", ISBN);
    bookElement.SetAttribute("genre", genre);
    bookElement.SetAttribute("publicationdate", publicationDate);

    // Get the values of child elements of a book.
    bookElement["title"].InnerText = title;
    bookElement["price"].InnerText = price;

    if (validateNode)
    {
        validateXML(generateSchema, bookElement.OwnerDocument);
    }
}
```



5.添加节点

若要添加节点，请使用 [CreateElement](https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmldocument.createelement?view=netcore-3.1) 方法或 [CreateNode](https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmldocument.createnode?view=netcore-3.1) 方法。

若要添加数据节点（如书籍），请使用 [CreateElement](https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmldocument.createelement?view=netcore-3.1) 方法。



```C#
public XmlElement AddNewBook(string genre, string ISBN, string misc,
    string title, string price, XmlDocument doc)
{
    // Create a new book element.
    XmlElement bookElement = doc.CreateElement("book", "http://www.contoso.com/books");
// Create attributes for book and append them to the book element.
XmlAttribute attribute = doc.CreateAttribute("genre");
attribute.Value = genre;
bookElement.Attributes.Append(attribute);

attribute = doc.CreateAttribute("ISBN");
attribute.Value = ISBN;
bookElement.Attributes.Append(attribute);

attribute = doc.CreateAttribute("publicationdate");
attribute.Value = misc;
bookElement.Attributes.Append(attribute);

// Create and append a child element for the title of the book.
XmlElement titleElement = doc.CreateElement("title");
titleElement.InnerText = title;
bookElement.AppendChild(titleElement);

// Introduce a newline character so that XML is nicely formatted.
bookElement.InnerXml =
    bookElement.InnerXml.Replace(titleElement.OuterXml,
    "\n    " + titleElement.OuterXml + " \n    ");

// Create and append a child element for the price of the book.
XmlElement priceElement = doc.CreateElement("price");
priceElement.InnerText= price;
bookElement.AppendChild(priceElement);

// Introduce a newline character so that XML is nicely formatted.
bookElement.InnerXml =
    bookElement.InnerXml.Replace(priceElement.OuterXml, priceElement.OuterXml + "   \n  ");

return bookElement;
}
```


#### 代码示例

###### `XmlDocument`模块代码

下面的示例包含两个主要类： `PurchaseOrder` 和 `Test`。 `PurchaseOrder` 类包含有关单个购买的信息。 `Test` 类包含创建采购订单的方法，并读取创建的采购订单。

```C#
using System;
using System.Xml;
using System.Xml.Serialization;
using System.IO;

/* The XmlRootAttribute allows you to set an alternate name
   (PurchaseOrder) of the XML element, the element namespace; by
   default, the XmlSerializer uses the class name. The attribute
   also allows you to set the XML namespace for the element.  Lastly,
   the attribute sets the IsNullable property, which specifies whether
   the xsi:null attribute appears if the class instance is set to
   a null reference. */
[XmlRootAttribute("PurchaseOrder", Namespace="http://www.cpandl.com",
IsNullable = false)]
public class PurchaseOrder
{
   public Address ShipTo;
   public string OrderDate;
   /* The XmlArrayAttribute changes the XML element name
    from the default of "OrderedItems" to "Items". */
   [XmlArrayAttribute("Items")]
   public OrderedItem[] OrderedItems;
   public decimal SubTotal;
   public decimal ShipCost;
   public decimal TotalCost;
}

public class Address
{
   /* The XmlAttribute instructs the XmlSerializer to serialize the Name
      field as an XML attribute instead of an XML element (the default
      behavior). */
   [XmlAttribute]
   public string Name;
   public string Line1;

   /* Setting the IsNullable property to false instructs the
      XmlSerializer that the XML attribute will not appear if
      the City field is set to a null reference. */
   [XmlElementAttribute(IsNullable = false)]
   public string City;
   public string State;
   public string Zip;
}

public class OrderedItem
{
   public string ItemName;
   public string Description;
   public decimal UnitPrice;
   public int Quantity;
   public decimal LineTotal;

   /* Calculate is a custom method that calculates the price per item,
      and stores the value in a field. */
   public void Calculate()
   {
      LineTotal = UnitPrice * Quantity;
   }
}

public class Test
{
   public static void Main()
   {
      // Read and write purchase orders.
      Test t = new Test();
      t.CreatePO("po.xml");
      t.ReadPO("po.xml");
   }

   private void CreatePO(string filename)
   {
      // Create an instance of the XmlSerializer class;
      // specify the type of object to serialize.
      XmlSerializer serializer =
      new XmlSerializer(typeof(PurchaseOrder));
      TextWriter writer = new StreamWriter(filename);
      PurchaseOrder po=new PurchaseOrder();

      // Create an address to ship and bill to.
      Address billAddress = new Address();
      billAddress.Name = "Teresa Atkinson";
      billAddress.Line1 = "1 Main St.";
      billAddress.City = "AnyTown";
      billAddress.State = "WA";
      billAddress.Zip = "00000";
      // Set ShipTo and BillTo to the same addressee.
      po.ShipTo = billAddress;
      po.OrderDate = System.DateTime.Now.ToLongDateString();

      // Create an OrderedItem object.
      OrderedItem i1 = new OrderedItem();
      i1.ItemName = "Widget S";
      i1.Description = "Small widget";
      i1.UnitPrice = (decimal) 5.23;
      i1.Quantity = 3;
      i1.Calculate();

      // Insert the item into the array.
      OrderedItem [] items = {i1};
      po.OrderedItems = items;
      // Calculate the total cost.
      decimal subTotal = new decimal();
      foreach(OrderedItem oi in items)
      {
         subTotal += oi.LineTotal;
      }
      po.SubTotal = subTotal;
      po.ShipCost = (decimal) 12.51;
      po.TotalCost = po.SubTotal + po.ShipCost;
      // Serialize the purchase order, and close the TextWriter.
      serializer.Serialize(writer, po);
      writer.Close();
   }

   protected void ReadPO(string filename)
   {
      // Create an instance of the XmlSerializer class;
      // specify the type of object to be deserialized.
      XmlSerializer serializer = new XmlSerializer(typeof(PurchaseOrder));
      /* If the XML document has been altered with unknown
      nodes or attributes, handle them with the
      UnknownNode and UnknownAttribute events.*/
      serializer.UnknownNode+= new
      XmlNodeEventHandler(serializer_UnknownNode);
      serializer.UnknownAttribute+= new
      XmlAttributeEventHandler(serializer_UnknownAttribute);

      // A FileStream is needed to read the XML document.
      FileStream fs = new FileStream(filename, FileMode.Open);
      // Declare an object variable of the type to be deserialized.
      PurchaseOrder po;
      /* Use the Deserialize method to restore the object's state with
      data from the XML document. */
      po = (PurchaseOrder) serializer.Deserialize(fs);
      // Read the order date.
      Console.WriteLine ("OrderDate: " + po.OrderDate);

      // Read the shipping address.
      Address shipTo = po.ShipTo;
      ReadAddress(shipTo, "Ship To:");
      // Read the list of ordered items.
      OrderedItem [] items = po.OrderedItems;
      Console.WriteLine("Items to be shipped:");
      foreach(OrderedItem oi in items)
      {
         Console.WriteLine("\t"+
         oi.ItemName + "\t" +
         oi.Description + "\t" +
         oi.UnitPrice + "\t" +
         oi.Quantity + "\t" +
         oi.LineTotal);
      }
      // Read the subtotal, shipping cost, and total cost.
      Console.WriteLine("\t\t\t\t\t Subtotal\t" + po.SubTotal);
      Console.WriteLine("\t\t\t\t\t Shipping\t" + po.ShipCost);
      Console.WriteLine("\t\t\t\t\t Total\t\t" + po.TotalCost);
   }

   protected void ReadAddress(Address a, string label)
   {
      // Read the fields of the Address object.
      Console.WriteLine(label);
      Console.WriteLine("\t"+ a.Name );
      Console.WriteLine("\t" + a.Line1);
      Console.WriteLine("\t" + a.City);
      Console.WriteLine("\t" + a.State);
      Console.WriteLine("\t" + a.Zip );
      Console.WriteLine();
   }

   private void serializer_UnknownNode
   (object sender, XmlNodeEventArgs e)
   {
      Console.WriteLine("Unknown Node:" +   e.Name + "\t" + e.Text);
   }

   private void serializer_UnknownAttribute
   (object sender, XmlAttributeEventArgs e)
   {
      System.Xml.XmlAttribute attr = e.Attr;
      Console.WriteLine("Unknown attribute " +
      attr.Name + "='" + attr.Value + "'");
   }
}
```

###### 输出的xml文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <ShipTo Name="Teresa Atkinson">
    <Line1>1 Main St.</Line1>
    <City>AnyTown</City>
    <State>WA</State>
    <Zip>00000</Zip>
  </ShipTo>
  <OrderDate>2020年5月14日</OrderDate>
  <Items>
    <OrderedItem>
      <ItemName>Widget S</ItemName>
      <Description>Small widget</Description>
      <UnitPrice>5.23</UnitPrice>
      <Quantity>3</Quantity>
      <LineTotal>15.69</LineTotal>
    </OrderedItem>
  </Items>
  <SubTotal>15.69</SubTotal>
  <ShipCost>12.51</ShipCost>
  <TotalCost>28.20</TotalCost>
</PurchaseOrder>
```

###### `XmlSerializer`模块

如果属性或字段返回一个复杂对象（如数组或类实例），则 `XmlSerializer` 将其转换为嵌套在主 XML 文档内的元素。

```c#
public class MyClass  
{  
    public MyObject MyObjectProperty;  
}  
public class MyObject  
{  
    public string ObjectName;  
}
```

###### 输出的xml文件

```xml
<MyClass>  
  <MyObjectProperty>  
  <ObjectName>My String</ObjectName>  
  </MyObjectProperty>  
</MyClass>
```

注意：对于过于复杂的类无法序列化

官方网站： https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.serialization.xmlserializer?view=netcore-3.1 

### Python解析和创建XML

Python中通过内建模块`xml.etree.ElementTree` （简称 `ET` ） 来操作XML。

XML是一种固有的分层数据结构，`ET`用树的方式来解析XML数据。

为此， `ET` 有两个类 `ElementTree` 将整个XML文档表示为一个树， `Element` 表示该树中的单个节点。与整个文档的交互（读写文件）通常在 `ElementTree` 级别完成。与单个XML元素及其子元素的交互是在 `Element` 级别完成的。

#### 代码示例

###### 解析的XML文本：`country_data.xml`

```xml
<?xml version="1.0"?>
<data>
    <country name="Liechtenstein">
        <rank>1</rank>
        <year>2008</year>
        <gdppc>141100</gdppc>
        <neighbor name="Austria" direction="E"/>
        <neighbor name="Switzerland" direction="W"/>
    </country>
    <country name="Singapore">
        <rank>4</rank>
        <year>2011</year>
        <gdppc>59900</gdppc>
        <neighbor name="Malaysia" direction="N"/>
    </country>
    <country name="Panama">
        <rank>68</rank>
        <year>2011</year>
        <gdppc>13600</gdppc>
        <neighbor name="Costa Rica" direction="W"/>
        <neighbor name="Colombia" direction="E"/>
    </country>
</data>
```

###### 载入xml文件

```python
import xml.etree.ElenmentTree as ET
tree = ET.parse('country_data.xml') #载入xml文件
root = tree.getroot() #获取根节点
print (root.tag,root.attribe) #作为一个 Element，root 有一个标记和一个属性字典
#'data' {}
for child in root:
    print(child.tag, child.attrib)#它还有我们可以迭代的子节点
#country {'name': 'Liechtenstein'}
#country {'name': 'Singapore'}
#country {'name': 'Panama'}
print(root[0][1].text)#子级是可以嵌套的，我们可以通过索引访问特定的子级节点
#'2008'
'''
Element.iter()可帮助递归遍历其下的所有子树（包括子级，子级的子级，等等）
'''
for neighbor in root.iter('neighbor'):
    print(neighbor.attrib)
#{'name': 'Austria', 'direction': 'E'}
#{'name': 'Switzerland', 'direction': 'W'}
#{'name': 'Malaysia', 'direction': 'N'}
#{'name': 'Costa Rica', 'direction': 'W'}
#{'name': 'Colombia', 'direction': 'E'}
'''
Element.findall() 仅查找当前元素的直接子元素中带有指定标签的元素。
Element.find() 找带有特定标签的 第一个 子级，
然后可以用 Element.text 访问元素的文本内容
Element.get(attribeName) 获取对应的属性
'''
for country in root.findall('country'):
    rank = country.find('rank').text
    name = country.get('name')
    print(name, rank)
#Liechtenstein 1
#Singapore 4
#Panama 68
'''
Element创建后可以直接操作 Element 对象。例如：使用 Element.text 修改文本字段，使用 Element.set() 方法添加和修改属性，以及使用 Element.append() 添加新的子元素。
'''
for rank in root.iter('rank'):
    new_rank = int(rank.text) + 1
    rank.text = str(new_rank)
    rank.set('updated', 'yes')
'''
可以使用 Element.remove() 删除元素。
'''
for country in root.findall('country'):
    rank = int(country.find('rank').text)
    if rank > 50:
        root.remove(country)
tree.write('output.xml')#ElementTree.write() 方法将其写入文件
```

###### 新建XML文档

```python
a = ET.Element('a') #新建元素
b = ET.SubElement(a, 'b')#创建子元素
c = ET.SubElement(a, 'c')
d = ET.SubElement(c, 'd')
ET.dump(a)	# 打印XML到控制台
```

###### 核心函数/参数

| 函数/属性 | 参数 | 描述 |
| --------- | ---- | ---- |
|           |      |      |
|           |      |      |
|           |      |      |



## 数据解析模块

## 任务解析

| **任务**                      |                                            |                                |
| ----------------------------- | ------------------------------------------ | ------------------------------ |
| **socket通讯模块**            | C#中为server服务端，Python中为client客户端 | `C#`:True,`Python`:underway    |
| **通讯协议规范**              | 规范各类命令与数据的传输方式和格式         |                                |
| xml解析模块                   |                                            | `C#`：True，`Python`：underway |
| C#解析命令                    |                                            | finished                       |
| Python解析命令                |                                            | wait for start                 |
| C#配置类的xml序列化与反序列化 |                                            | wait for start                 |
| Python载入和修改xml           |                                            | underway                       |
| C#server与驱动库链接          |                                            | finished                       |
| client人机交互                |                                            | underway                       |
| **数据解析模块**              |                                            | underway                       |

### 

socket通讯模块：

通讯协议规范：

发送的命令格式:

```xml
<DAQ>
	<command>命令码<\command>
    <voltag><\voltag>
</DAQ>
```

| 命令码             | 描述                                                         | 返回                                                         | 额外参数                                                     | 返回参数                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **操作命令**       |                                                              |                                                              |                                                              |                                                              |
| `connectUSB`       | 连接USB设备                                                  | 连接成功：1；未连接成功：0；发生错误；-1                     | NULL                                                         | NULL                                                         |
| `setSC`            | 从存储`SlowControl`配置信息的XML读取配置信息，向USB设备发送配置信息 | 配置成功：1；未配置成功：0；发生错误：-1                     | [<SCPath>XML路径</SCPath>]：如果没有设置则为默认配置         | NULL                                                         |
| `switchHV`         | 开关高压模块                                                 | 设置成功：1；未设置成功：0；发生错误：-1                     | <on-off>bool<on-off>：True为开启，Flase为关闭                | NULL                                                         |
| `setHV`            | 设置高压                                                     | 设置成功：1；未设置成功：0；发生错误：-1                     | <voltag>float</voltag>：表示目标电压                         | NULL                                                         |
| `smoothHV`         | 平滑调节高压                                                 | 设置成功：1；未设置成功：0；发生错误：-1                     | <voltag>float</voltag>：表示目标电压                         | 在平滑调节的过程中会不断反馈当前电压值：<voltage>float</voltage>；当调节完成后才返回return项。 |
| `startAcceptData`  | 开启接收数据线程                                             | 操作成功：1；操作失败：0；发生错误：-1                       | [<DataDir>指定Data保存文件夹路径</DataDir>]：如果没有设置则保存到默认路径 | <DataPath>路径</DataPath>：数据存储的绝对路径                |
| `stopAcceptData`   | 关闭数据接收线程                                             | 操作成功：1；操作失败：0；发生错误：-1                       | NULL                                                         |                                                              |
| `exit`             | 退出communication进程                                        | 成功退出：1；退出失败（比如还有正在运行的任务）：0；发生错误：-1 | NULL                                                         | 当进程即将结束时，会额外发送一次消息：<exit />               |
| **获取状态的命令** |                                                              |                                                              |                                                              |                                                              |
| `alive`            | 检查进程是否还在正常运行                                     | 还在运行：1；                                                | NULL                                                         | 如果超时未返回则认为进程已经死掉。                           |
| `checkUSB`         | 检查USB设备是否上线（仍在连接）                              | 正常搜索到设备：1；未搜索到设备：0；发生错误：-1             | NULL                                                         | NULL                                                         |
| `HV`               | 查看高压状态                                                 | 正常执行：1；发生错误：-1                                    | [<arg>argument</arg>]：如果没有指定，则返回HV开关状态和HV电压值。指定voltage则只返回HV电压值，指定switch则只返回HV开关状态。 | [<switch>bool</switch>]：True为HV模块已开启，False为HV模块未开启。[<voltage>float</voltage>]：返回当前高压模块的电压值。 |
| `SC`               | 查看`slowControl`配置情况                                    | 正常执行：1；发生错误：-1                                    | NULL                                                         | 在当前通讯外，会进行一次新的UDP会话，发送一个XML文件来描述`slowControl`的配置情况。 |
| `probe`            | 查看`probe`配置情况                                          | 正常执行：1；发生错误：-1                                    | NULL                                                         | 在当前通讯外，会进行一次新的UDP会话，发送一个XML文件来描述`probe`的配置情况。 |

```xml
<DAQ>
	<return>1<\return>
	<INFO><\INFO>
	<ERROR><\ERROR>
<\DAQ>
```

|        | 信息                     | 备注                                             |
| ------ | ------------------------ | ------------------------------------------------ |
| return | 1、0、-1                 | 返回0时会附加INFO节点，返回-1时会附加ERROR节点。 |
| INFO   | 造成命令未成功执行的原因 |                                                  |
| ERROR  | 错误信息                 |                                                  |
